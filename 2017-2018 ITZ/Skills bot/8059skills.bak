#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, in2,    pot_mGoal,      sensorPotentiometer)
#pragma config(Sensor, dgtl1,  encLeft,        sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  encRight,       sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  encOdo,         sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  ime_driveR,     sensorNone)
#pragma config(Sensor, I2C_2,  ime_driveL,     sensorNone)
#pragma config(Motor,  port2,           driveLY,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           driveL2,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           driveL1,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           mgLiftL,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           mgLiftR,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           driveR1,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           driveR2,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           driveRY,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          claw,          tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)
#pragma competitionControl(Competition)
static int autonomousMode = 0;
#include "Vex_Competition_Includes_M.c"
#include "auton_library_8059.c"
#include "getlcdbuttons.c"

/************************************************************************************/
/************************************* Setting **************************************/
/************************************************************************************/
//Select the operating habits
#define HJM

#ifdef HJM
#define mainJoyY Ch3 //ch2
#define mainJoyX Ch1 //ch4
#define secondaryJoyY Ch4
#define secondaryJoyX Ch2
#endif
/************************************************************************************/
/************************************** Common **************************************/
/************************************************************************************/

/************************************************************************************/
/******************************** Automous ******************************************/
/************************************************************************************/
#define MAX_CHOICE  3
#define MAX_CHOICE_LCD  2
static int lcdTelemMode = 0;
bool mAutonBool = false;
int autonNumber = 0;

void pre_auton()
{
	bStopTasksBetweenModes = true;
}

#include "autons_raw_8059.c"
task autonomous(){
	resetAll();
	initPids();
	clearDebugStream();
	clearLCDLine(0);clearLCDLine(1);
	switch (autonomousMode){
	case 0:
		skills178();
		break;
	case 1:

		break;
	case 2:

		break;
	case 3:

		break;
	default:
		break;
	}
}
/************************************************************************************/
/******************************* User control ***************************************/
/************************************************************************************/
void LcdAutonomousSet( int value, bool select = false )
{
	if(select) autonomousMode = value;
	if(autonomousMode == value) mAutonBool = true;
	else mAutonBool = false;
}

task LcdAutonomousSelection()
{
	TControllerButtons  button;
	autonNumber = 0;
	bLCDBacklight = true;
	mAutonBool = false;
	LcdAutonomousSet(0);
	while( true ){
		button = getLcdButtons();
		if( ( button == kButtonLeft ) || ( button == kButtonRight ) ) {
			if( button == kButtonLeft )
				if( --autonNumber < 0 ) autonNumber = MAX_CHOICE;
			if( button == kButtonRight){
				++lcdTelemMode;
				if( lcdTelemMode > MAX_CHOICE_LCD ) lcdTelemMode = 0;
				clearLCDLine(0);
			}
			LcdAutonomousSet(autonNumber);
		}
		if( button == kButtonCenter)
			LcdAutonomousSet( autonNumber, true );
		delay(25);
	}
}

int moveL_spd=0, moveR_spd=0;
void Robot_Move(int vy,int turn,float vy_max_speed,float turn_max_speed,float abs_max_speed)
{
	//reverse y
	vy*=-1;
	turn*=-1;
	bool move_protect_start = false;
	float vl;
	float vr;

	if(abs(vy)<=20) vy=0;
	if(abs(turn)<=20) turn=0;
	if(abs(vy)<vy_max_speed) vy=vy*vy_max_speed/127.0;
	if(abs(turn)<turn_max_speed) turn=turn*turn_max_speed/127.0;
	vl=vy+turn;
	vr=vy-turn;
	//anti slip
	///*if(abs(vl - vr) > 50)
	//{
	//	if(vl > vr) vr = vl * sgn(vr);
	//	else vl = vr * sgn(vl);
	//}
	//else */
	if(abs(vl) < 20)
	{
		int pwr_plus = 20 - abs(vl);
		pwr_plus *= sgn(vl);
		vl += pwr_plus;
		vr += pwr_plus;
	}
	else if(abs(vr) < 20)
	{
		int pwr_plus = 20 - abs(vr);
		pwr_plus *= sgn(vr);
		vl += pwr_plus;
		vr += pwr_plus;
	}

	if(move_protect_start && abs(vl - vr) < 25 && sgn(vl) != sgn(vr))
	{
		if(abs(moveL_spd) < 3)
		{

			if(vl <= 25) vl *= 1;
			else if(vl > 25 && vl <= 45) vl *= 0.85;
			else if(vl > 45 && vl < 90) vl = 45;
			else if(vl >= 90) vl = 50;
			//writeDebugStream("SPEED DOWN: SPD_L:%d PWR_L:%d\n",moveL_spd, vl);
		}
		else if(abs(moveL_spd) <15 && abs(motor[mDRIVEL_1]) > 20)
		{
			vl *= 0.9;
			//writeDebugStream("SPEED DOWN: SPD_L:%d PWR_L:%d\n",moveL_spd, vl);
		}

		if(abs(moveR_spd) < 3)
		{
			if(vr <= 25) vr *= 1;
			else if(vr > 25 && vr <= 45) vr *= 0.85;
			else if(vr > 45 && vr < 90) vr = 45;
			else if(vr >= 90) vr = 50;
		//	writeDebugStream("SPEED DOWN: SPD_R:%d PWR_R:%d\n",moveR_spd, vr);
		}
		else if(abs(moveR_spd) < 15 && abs(motor[mDRIVER_1]) > 20)
		{
			vr *= 0.9;
			//writeDebugStream("SPEED DOWN: SPD_R:%d PWR_R:%d\n",moveR_spd, vr);
		}
		//else writeDebugStream("OK: SPD_R:%d PWR_R:%d\n",moveR_spd, vr);
	}

	if(abs(vl)>=abs_max_speed) vl=sgn(vl)*abs_max_speed;

	if(abs(vr)>=abs_max_speed) vr=sgn(vr)*abs_max_speed;

	//writeDebugStream("NORMAL: SPD_R:%d PWR_R:%d\n",moveR_spd, vr);

	setWheelSpeed(vl, vr);
}

void RT_MOVE()
{
	if(abs(vexRT[mainJoyX]) > 123 && abs(vexRT[mainJoyY]) < 123) Robot_Move(vexRT[mainJoyY] ,90*sgn(vexRT[mainJoyX]),75,127,100);
	else if(abs(vexRT[mainJoyX]) < 123 && abs(vexRT[mainJoyY]) > 123) Robot_Move(100*sgn(vexRT[mainJoyY]) ,vexRT[mainJoyX],127,70,100);
	else if(abs(vexRT[mainJoyX]) > 123 && abs(vexRT[mainJoyY]) > 123) Robot_Move(vexRT[mainJoyY] ,vexRT[mainJoyX],100,90,100);
	else if(abs(vexRT[mainJoyY]) > 110 && abs(vexRT[mainJoyY]) <= 123 && abs(vexRT[mainJoyX]) < 123) Robot_Move(75*sgn(vexRT[mainJoyY]) ,vexRT[mainJoyX],127,70,75);
	else if(abs(vexRT[mainJoyX]) > 110 && abs(vexRT[mainJoyX]) <= 123 && abs(vexRT[mainJoyY]) < 123) Robot_Move(vexRT[mainJoyY] ,70*sgn(vexRT[mainJoyX]),75,127,75);
	else Robot_Move(vexRT[mainJoyY],vexRT[mainJoyX],75,70,75);
}


void FwLcdControl_user()
{
	clearLCDLine(0);
	char str0[32]; char str1[32];
	switch(lcdTelemMode)
	{
	case 0:
		sprintf( str0, "%d %d", GetAngle(), getSensorPotMGoal());
		break;
	case 1:
		sprintf( str0, "O:%d L:%d R:%d ", SensorValue[sENCO], SensorValue[sENCR], SensorValue[sENCL] );
		break;
	case 2:

		break;
	default:
		clearLCDLine(0); break;
	}
	sprintf( str1, "B(%d)%d %1.2f", mAutonBool, autonNumber, nImmediateBatteryLevel/1000.0 );
	displayLCDString(0, 0, str0);
	displayLCDString(1, 1, str1);
}

task ParaCalc(){
	int moveR_previous = 0;
	int moveL_previous = 0;
	while(true){
		delay(50);
		moveL_spd = getEncLeft() - moveL_previous;
		moveR_spd = getEncRight() - moveR_previous;
		moveL_previous = getEncLeft();
		moveR_previous = getEncRight();
	}
}

task usercontrol()
{
	resetAll();

	stopTask(MobileGoalControl);
	stopTask(ClawControl);

	startTask(LcdAutonomousSelection);
	startTask(ParaCalc);
	startTask(ClawControl);

	int threshold = 20;
	int mainX = 0,mainY = 0,secondaryX = 0,secondaryY = 0;

	while(true)
	{
		FwLcdControl_user();
		//RT_MOVE();
		if(abs(vexRT[mainJoyY]) >= threshold)	mainY = vexRT[mainJoyY];
		else	mainY = 0;
		if(abs(vexRT[mainJoyX]) >= threshold)	mainX = vexRT[mainJoyX];
		else	mainX = 0;
		if(abs(vexRT[secondaryJoyY]) >= threshold)	secondaryY = vexRT[secondaryJoyY];
		else	secondaryY = 0;
		if(abs(vexRT[secondaryJoyX]) >= threshold)	secondaryX = vexRT[secondaryJoyX];
		else	secondaryX = 0;
		if(abs(mainY) < abs(secondaryY)) mainY = secondaryY;
		if(abs(mainX) < 40) mainX /= 2;

		//pwrDriveRight((-mainY + -mainX)*0.7874);
		//pwrDriveLeft((-mainX - -mainY)*0.7874);

		pwrDriveRight((mainY - mainX)*0.7874);
		pwrDriveLeft((mainX + mainY)*0.7874);

		if(vexRT[Btn6U]) setMGLiftMotor(-127);
		else if(vexRT[Btn6D]) setMGLiftMotor(127);
		else {
			if(getSensorPotMGoal()<=1700) setMGLiftMotor(20);
			else setMGLiftMotor(0);
		}



		delay(30);
	}
}
