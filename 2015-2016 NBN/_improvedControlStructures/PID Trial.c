#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           LDrive,        tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port3,           RDrive,        tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port4,           Hook,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           Motor_FWL,     tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port8,           Motor_FWR,     tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port9,           Intake,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

// Update inteval (in mS) for the flywheel control loop
#define FW_LOOP_SPEED              20

// Maximum power we want to send to the flywheel motors
#define FW_MAX_POWER              127

// encoder counts per revolution depending on motor
#define MOTOR_TPR_269           240.448
#define MOTOR_TPR_393R          261.333
#define MOTOR_TPR_393S          392
#define MOTOR_TPR_393T          627.2
#define MOTOR_TPR_QUAD          360.0


// encoder tick per revolution
float           ticks_per_rev;          ///< encoder ticks per revolution

// Encoder
long            encoder_counts;         ///< current encoder count
long            encoder_counts_last;    ///< current encoder count


// velocity measurement
float           motor_velocity;         ///< current velocity in rpm
long            nSysTime_last;          ///< Time of last velocity calculation


// control algorithm variables
long            target_velocity;        ///< target_velocity velocity
float           current_error;          ///< error between actual and target_velocity velocities
float           last_error;             ///< error last time update called
float						accumulated_error;				///< total accumulated error



// final motor drive
long            motor_drive;


/*Set the flywheel motors */
void FwMotorSet( int value )
{
	motor[ Motor_FWR ] = value;
}


/*Get the flywheen motor encoder count*/
long FwMotorEncoderGet()
{
	return( nMotorEncoder[ Motor_FWR ] );
}



/*Set the controller position*/
void FwVelocitySet( int velocity )
{
	// set target_velocity velocity (motor rpm)
	target_velocity = velocity;

	// Set error so zero crossing is correctly detected
	current_error = target_velocity - motor_velocity;
	last_error    = current_error;


}




/*Calculate the current flywheel motor velocity*/
void FwCalculateSpeed()
{
	int     delta_ms;
	int     delta_enc;


	// Get current encoder value
	encoder_counts = FwMotorEncoderGet();



	// calculate change in syste time
	delta_ms = nSysTime - nSysTime_last;
	nSysTime_last = nSysTime;


	// Change in encoder count
	delta_enc = (encoder_counts - encoder_counts_last);


	// save last position
	encoder_counts_last = encoder_counts;


	// Calculate velocity in rpm
	motor_velocity = (1000.0 / delta_ms) * delta_enc * 60.0 / ticks_per_rev;

	// calculate error in velocity
	current_error = target_velocity - motor_velocity;


	// Save last error
	last_error = current_error;



}



/*Task to control the velocity of the flywheel */
task ShooterControl()
{
	float kp = 0.59;
	float ki = 0.0;
	float kd = 0;


	float proportional;
	float integral;
	float derivative;


	//PID control code
	while(true)
	{

		proportional = current_error * kp;

		accumulated_error = accumulated_error + current_error;

		integral = accumulated_error * ki;

		derivative = (current_error - last_error) * kd;

		last_error = current_error;

		datalogAddValueWithTimeStamp(0, proportional);

	// We are using Speed geared motors
	// Set the encoder ticks per revolution
	ticks_per_rev = MOTOR_TPR_393S;



		// Calculate velocity
		FwCalculateSpeed();


		// Scale drive into the range the motors need
		motor_drive  = (proportional + integral + derivative);

		// Final Limit of motor values - don't really need this
		if( motor_drive >  127 ) motor_drive =  127;
		if( motor_drive < 0 ) motor_drive = 0;


		// and finally set the motor control value
		FwMotorSet( motor_drive );

		// Run at somewhere between 20 and 50mS
		wait1Msec( FW_LOOP_SPEED );
}
}


task usercontrol()
{
	// Start the flywheel control task
	startTask( ShooterControl );

	// Main user control loop
	while(1)
	{
		//Tank control
		tankControl( Ch3, Ch2, 10 );

		//Hook control
		if(vexRT[Btn6DXmtr2] == 1)
		{
			motor[Hook] = 100;
		}
  	else if(vexRT[Btn6UXmtr2] == 1)
		{
			motor[Hook] = -40;
	}
	else
	{
   motor[Hook] = 0;
  }
/////////////
		// Different speeds set by buttons
		if( vexRT[ Btn8UXmtr2 ] == 1 )
		{
			FwVelocitySet( 114 );

		}
		if( vexRT[ Btn8LXmtr2 ] == 1 )
		{
			FwVelocitySet( 110 );

		}
		if( vexRT[ Btn8DXmtr2 ] == 1 )
		{
			FwVelocitySet( 60 );

		}
		if( vexRT[ Btn8RXmtr2 ] == 1 )
		{
			FwVelocitySet( 0.0 );

		}

		if( vexRT[ Btn7UXmtr2 ] == 1 )
			motor[Intake] = 55;
		else if( vexRT[ Btn7DXmtr2 ] == 1 )
			motor[Intake] = -127;
		else
			motor[Intake] = 0;


		// Don't hog the cpu :)
		wait1Msec(20);
	}
}

void pre_auton()
{

}

task autonomous()
{
	// Start the flywheel control task
	startTask( ShooterControl );

	// Main user control loop
	while(1)
	{
		//Start Flywheels

		FwVelocitySet( 107 );

		if( motor[Intake] == 0 )
		{
			//Intake Delay
			wait1Msec( 3000);

			//Start Intake
			motor[ Intake	] = 50;
		}
	}
}
