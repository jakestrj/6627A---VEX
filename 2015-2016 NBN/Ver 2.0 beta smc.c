#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(Sensor, dgtl1,  encoderR,       sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  encoderL,       sensorQuadEncoder)
#pragma config(Motor,  port2,           baseR,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           baseR,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           lift1,         tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           launch1,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           launch2,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           grab,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           bassL,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           baseL,         tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

int power;
float vL;
float vR;

long            encoder_countsR;         ///< current encoder count
long            encoder_counts_lastR;    ///< current encoder count
float           motor_velocityR;         ///< current velocity in rpm
float           motor_velocityL;         ///< current velocity in rpm
long            nSysTime_last;          ///< Time of last velocity calculation
float           ticks_per_rev;          ///< encoder ticks per revolution
long            encoder_countsL;         ///< current encoder count
long            encoder_counts_lastL;    ///< current encoder count
float currentR;
float currentL;
float lastR;
float lastL;
float inputV;

void setSpeed(int a){
	power = a;
}

task baseControl(){
	while(true){

		motor[port2] = (vexRT[Ch4]-vexRT[Ch2]);
		motor[port3] = (vexRT[Ch4]-vexRT[Ch2]);
		motor[port8] = (vexRT[Ch4]+vexRT[Ch2]);
		motor[port9] = (vexRT[Ch4]+vexRT[Ch2]);

	}
}
long
FwMotorEncoderGetR()
{
    return abs( SensorValue[encoderR] );
}

long
FwMotorEncoderGetL()
{
    return abs(	SensorValue[encoderL] );
}

void
FwCalculateSpeed()
{
		char  str[32];
    currentR = FwMotorEncoderGetR();
    currentL = FwMotorEncoderGetL();
    //Take the difference in the sensor value since the last reading, convert from degrees to rotations, convert 1/20 second to minutes
    motor_velocityR = (currentR - lastR) / 360 * 20 *60; //You can simplify the math if you want
    motor_velocityL = (currentL - lastL) / 360 * 20 *60;
    sprintf( str, "%4d %4d  %5.2f", inputV,  motor_velocityR/7.0, nImmediateBatteryLevel/1000.0 );
    displayLCDString(0, 0, str );
    lastR = currentR;
    lastL = currentL;
    datalogDataGroupStart();
    datalogAddValue(1,motor_velocityL/7.0);
    datalogAddValue(2,motor_velocityR/7.0);
    datalogDataGroupEnd();
    wait1Msec(50);
}


task lift(){

	while(true){
		if(vexRT[Btn5U] == 1){
			motor[port4] = 127;
		}
		if(vexRT[Btn5D] == 1){
			motor[port4] = -127;
		}
		else if(vexRT[Btn5D] == 0 && vexRT[Btn5U] == 0){
			motor[port4] = 0;
		}
	}
}
task shootPID(){
    float kp = 0.1; //1.4
    float ki = 0;  //0.6
    float kd = 0;  //Minor adj = 0

    float currentL = 0;
    float currentR = 0;

    float intergralActiveZone = 80;
    float errorTl;
    float errorTr;
    float lastErrorL;
    float lastErrorR;
    float propertionL;
    float propertionR;
    float integralL;
    float integralR;
    float derivativeL;
    float derivativeR;

    while(true){

   			float errorL;
   			float errorR;
   			if( inputV != 0){
				vR = abs(motor_velocityR)/7.0;
				vL = abs(motor_velocityL)/7.0;
   				errorL = inputV - vL;
       	  errorR = inputV - vR;
      }
      else{
      	errorL = 0;
      	errorR = 0;
      }


    if(errorL < intergralActiveZone && errorL != 0){
        errorTl += errorL;
    }

    if(errorR < intergralActiveZone && errorR != 0){
        errorTr += errorR;
    }

    if(ki != 0 && errorTl > 50/ki){
        errorTl = 50/ki;
    }
    if(ki != 0 && errorTr > 50/ki){
        errorTr = 50/ki;
    }
    if(errorL == 0){
        derivativeL = 0;
    }
    if(errorR == 0){
        derivativeR = 0;
    }
    propertionL = errorL*kp;
    propertionR = errorR*kp;
    integralL = errorTl*ki;
    integralR = errorTr*ki;
    derivativeL = (errorL-lastErrorL)*kd;
    derivativeR = (errorR-lastErrorR)*kd;

    lastErrorL = errorL;
    lastErrorR = errorR;

    currentL = propertionL + integralL + derivativeL;
    currentR = propertionR + integralR + derivativeR;

    if(currentL < 0){
        currentL = 0;
    }
    if(currentR < 0){
        currentR = 0;
    }
    if(currentL > 127){
        currentL = 127;
    }
    if(currentR > 127){
        currentR = 127;
    }
    motor[port5] = currentL;
    motor[port6] = currentR;

    if(vexRT[Btn7D] == 1){
        motor[port5] = motor[port6] = 0;
    }
    waitInMilliseconds(20);
    }
}
task grabControl(){
	while(true){
		if(vexRT[Btn6U] == 1){
			motor[port7] = -127;
		}
		else if(vexRT[Btn6D] == 1){
			motor[port7] = 127;
		}
		else if(vexRT[Btn6D] == 0 && vexRT[Btn6U] == 0){
			motor[port7] = 0;
		}
	}
}


task autoMode1(){
		stopTask(usercontrol);
		stopTask(shootPID);
		wait1Msec(3000);
		motor[port2] = -127; //right
		motor[port3] = -127;
		motor[port8] = -127;
		motor[port9] = -127;
		wait1Msec(1000);
		motor[port2] = 0; //right
		motor[port3] = 0;
		motor[port8] = 0;
		motor[port9] = 0;
	inputV = 173;
	FwCalculateSpeed();
	startTask(shootPID);
	while(true){
		FwCalculateSpeed();
		if(motor_velocityR/7.0 > 153&& motor_velocityR/7.0 < 165){
  		  	motor[port7] = -127;
  	}
  	else{
  		  	motor[port7] = 0;
  	}
	}



}
void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////
task autoMode2(){
	stopTask(usercontrol);
		stopTask(shootPID);
	inputV = 195;
	FwCalculateSpeed();
		startTask(shootPID);
	while(true){
		FwCalculateSpeed();
		if(motor_velocityR/7.0 > 169&& motor_velocityR/7.0 < 175){
  		  	motor[port7] = -127;
  	}
  	else{
  		  	motor[port7] = 0;
  	}
	}
}

task autonomous(){
	startTask(autoMode1);
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	stopTask(autonomous);
	stopTask(shootPID);
	 bLCDBacklight = true;
	 int maxB = 0;
	 int minB = 0;
	// User control code here, inside the loop
	setSpeed(90);
	inputV = 0;
  //startTask(grabControl);
  startTask(baseControl);
 	startTask(lift);
 	//startTask(grabControl);
 	//startTask(dataLog);
  while(true){
  	FwCalculateSpeed();
  	if(vexRT[Btn7U] == 1){
  			stopTask(shootPID);
  			inputV = 220;
  			 maxB=50;
  		  minB=38;
  		  startTask(shootPID);

  	}
  	else if(vexRT[Btn7L] == 1){
  			stopTask(shootPID);
  			inputV = 210;
  			 maxB=31;
  		  minB=20;
  		  startTask(shootPID);

  	}
  		else if(vexRT[Btn7R] == 1){
  			stopTask(shootPID);
  			inputV = 200;
  			 maxB=31;
  		  minB=20;
  		  startTask(shootPID);
  	}
  	else if(vexRT[Btn8R] == 1){
  			stopTask(shootPID);
  			inputV = 180;
  			 maxB=23;
  		  minB=10;
  		  startTask(shootPID);
  	}
  	else if(vexRT[Btn8L] == 1){
  			stopTask(shootPID);
  			inputV = 160;
  			 maxB=15;
  		  minB=9;
  		  startTask(shootPID);
  	}
  	else if(vexRT[Btn7D] == 1){
  		stopTask(shootPID);
  		inputV = 0;
  		motor[port5] = 0;
  		motor[port6] = 0;
  		maxB=0;
  		  minB=0;
  	}
  	else if(vexRT[Btn8D] == 1){
  		stopTask(shootPID);
  		inputV = 170;
  		maxB=20;
  		minB=10;
  		startTask(shootPID);
  	}
  	if(motor_velocityR/7.0 >= inputV-maxB && motor_velocityR/7.0 <= inputV-minB && motor_velocityR != 0 && vexRT[Btn6D] == 0|| vexRT[Btn6U] == 1){
 					motor[port7] = -127;
  		  }
  		  else if(vexRT[Btn6D] == 1 && vexRT[Btn8U] == 0){
  		  	motor[port7] = 127;
  		  }
  		  else if(vexRT[Btn8U] == 1 && vexRT[Btn6D] == 0 && inputV == 0){
  		  	motor[port7] = 127;
  		  	motor[port5] = -55;
  		  	motor[port6] = -55;
  		  	wait1Msec(100);
  		  	motor[port5] = 0;
  		  	motor[port6] = 0;
  		  }
  		  else{
  		  	motor[port7] = 0;
  		  }
  }
}
