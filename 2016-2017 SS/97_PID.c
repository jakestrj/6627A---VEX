#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(Sensor, in1,    pot_clawL,      sensorPotentiometer)
#pragma config(Sensor, in2,    pot_clawR,      sensorPotentiometer)
#pragma config(Sensor, in3,    pot_lift,       sensorPotentiometer)
#pragma config(Sensor, dgtl1,  quad_driveL,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  quad_driveR,    sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  leftClawIME,    sensorNone)
#pragma config(Sensor, I2C_2,  rightClawIME,   sensorNone)
#pragma config(Motor,  port1,           driveR1,       tmotorVex393TurboSpeed_HBridge, openLoop, encoderPort, dgtl3)
#pragma config(Motor,  port2,           driveR2,       tmotorVex393TurboSpeed_MC29, openLoop, encoderPort, dgtl3)
#pragma config(Motor,  port3,           liftRY,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           driveR3,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           clawL,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           clawR,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           driveL3,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           liftLY,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           driveL2,       tmotorVex393TurboSpeed_MC29, openLoop, reversed, encoderPort, dgtl1)
#pragma config(Motor,  port10,          driveL1,       tmotorVex393TurboSpeed_HBridge, openLoop, encoderPort, dgtl1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"
#include "auton_library_97.c"
#include "getlcdbuttons.c"

/************************************************************************************/
/************************************* Setting **************************************/
/************************************************************************************/
//Select the operating habits
#define HJM
//Automatically lower the robot arm
#define AUTOPUTDOWN false

#ifdef HJM
#define mainJoyY Ch4
#define mainJoyX Ch2
#define secondaryJoyY Ch4
#define secondaryJoyX Ch2
#endif

#ifdef XPZ
#define mainJoyY Ch1
#define mainJoyX Ch3
#define secondaryJoyY Ch1
#define secondaryJoyX Ch3
#endif
/************************************************************************************/
/************************************** Common **************************************/
/************************************************************************************/

bool auto_8L = false, auto_8R = false, auto_6D = false, auto_6U = false;

void setArmMotor(int power)
{
	motor[liftRY] = power;
	//motor[liftR] = power;
	//motor[liftL] = power;
	motor[liftLY]= power;
}

void setArmMotorWithHighTech(int power)
//Better linear performance
{
	if(power > 2)
	{
		motor[liftRY] = power*0.92 + 8;
		//motor[liftR] = power*0.92 + 8;
		//motor[liftL] = power*0.92 + 8;
		motor[liftLY]= power*0.92 + 8;
	}
	else if(power < -2)
	{
		motor[liftRY] = power*0.92 - 8;
		//motor[liftR]= power*0.92 - 8;
		//motor[liftL] = power*0.92 - 8;
		motor[liftLY]= power*0.92 - 8;
	}
	else
	{
		motor[liftRY] = 0;
		//motor[liftR]= 0;
		//motor[liftL] = 0;
		motor[liftLY]= 0;
	}
}


void putOutClaw(void)
{
	pwrClaw(-100);
	delay(500);
	pwrClaw(0);
}

void putOutClawMid(void)
{
	pwrClaw(-100);
	delay(75);
	pwrClaw(0);
}

void putInClawMid(void)
{
	pwrClaw(100);
	delay(75);
	pwrClaw(0);
}

task openClawOnTick(){
	int isExtended = false;
	while(true){
		if(getSensorPotLift()>1750 && !isExtended) { isExtended=true; putOutClaw(); }
		delay(25);
	}
}

void putDownArm(void)
{
	int lastAngle;
	//Quickly lower the robot arm
	setArmMotor(-127);
	delay(100);
	do{
		lastAngle = getSensorPotLift();
		delay(50);
	}while(/*lastAngle - getSensorPotLift() > 0 && */getSensorPotLift() > 1300);
	//Slowly approaching the lowest position(When stopped, stop)
	setArmMotor(-127);
	do{
		lastAngle = getSensorPotLift();
		delay(50);
	}while(lastAngle - getSensorPotLift() > 0);
	if(getSensorPotLift() < 1100)
	//if successfully put down,power up briefly to ensure that it is not
	{
		delay(50);
		setArmMotor(-100);
		delay(100);
	}
	else
	//If it fails, lift it lightly
	{
		setArmMotor(100);
		delay(100);
	}
	setArmMotor(-7);//Make it static
}

void putUpArm(void)
{
	//Full-speed elevation until blocked
	startTask(openClawOnTick);
	int lastAngle;
	setArmMotor(127);
	delay(100);
	do{
		lastAngle = getSensorPotLift();
		delay(50);
	}while(getSensorPotLift() - lastAngle > 0 && getSensorPotLift() < 3000);
}

#define LOWEST -1
#define HIGHEST -2
task armControl()
{
	enum STATE{remainToBeDone, working, done, pause};
	enum STATE stata = done;
	int aim = LOWEST;
	long iNow;int pNow, vNow;
	int pLast;
	int kP, kI, kV, slewRate, maxPower;
	int power = 0, lastPower;

	while(true)
	{
		//Button recognition and preprocessing
		if(time1[T1] > 300)//Prevent double-click
		{
			if(vexRT[Btn6D] || vexRT[Btn7D] || auto_6D)
			{
				auto_6D = false;
				aim = LOWEST;
				stata = remainToBeDone;
			}
			if(vexRT[Btn8L] || vexRT[Btn7R] || auto_8L)
			{
				auto_8L = false;
				int lastAngle;
				clearTimer(T2);
				setArmMotor(127);
				do{
					lastAngle = getSensorPotLift();
					delay(50);
				}while(getSensorPotLift() < 1350 && time1[T2] < 400);
				setArmMotor(0);

				aim = 1900;
				stata = remainToBeDone;
			}
			if(vexRT[Btn6U] || vexRT[Btn7U] || auto_6U)
			{
				auto_6U = false;
				aim = HIGHEST;
				stata = remainToBeDone;
			}
			if(vexRT[Btn8R] || vexRT[Btn7L] || auto_8R)
			{
				auto_8R = false;
				int lastAngle;
				clearTimer(T2);
				setArmMotor(80);
				int angleStart = getSensorPotLift();
				clearTimer(T3);
				do{
					lastAngle = getSensorPotLift();
					if(lastAngle - angleStart > 250 //check when lifting a certain angle
						&& (time1[T3] < 320 //if lifting too fast
						|| motor[driveR1] < -60 || motor[driveL1] < -60))
						//or when the driver reversing(This means that the driver thinks the action has been done)
					{
						writeDebugStream("%d\n",time1[T3]);
						setArmMotor(-10);
						delay(150);
						setArmMotor(0);
						break;
					}
					delay(10);
				}while(getSensorPotLift() < 1350 && time1[T2] < 600);
				aim = 1600;
				stata = remainToBeDone;
			}
		}
		if(stata == remainToBeDone)
			clearTimer(T1);

		//Perform the operation
		if(aim == LOWEST && stata != done)
		{
			putDownArm();
			stata = done;
		}
		else if(aim == HIGHEST && stata != done)
		{
			putUpArm();
			if(AUTOPUTDOWN)
			{
				delay(200);
				putDownArm();
			}else{
				setArmMotor(0);
			}
			stopTask(openClawOnTick);
			stata = done;
		}
		else if(aim != HIGHEST && aim != LOWEST)
		{
			if(stata == remainToBeDone)//The first cycle of PID, initialization
			{
				stata = working;
				pLast = pNow = aim - getSensorPotLift();
				iNow = 0;
				vNow = 0;
				clearTimer(T3);
			}
			else//Process sensor data
			{
				pLast = pNow;
				pNow = aim - getSensorPotLift();
				iNow += pNow;
				vNow = pLast - pNow;
			}

			//Dynamically set parameters
			kP = 60;
			kI = 10;
			if(abs(kI*iNow) > 40000)//When stuck, remove the exception
				iNow = 40000/kI*sgn(iNow);
			kV = 400;
			slewRate = 15;

			maxPower = 127;
			if(time1[T3] > 500)
				maxPower = 25;
			if(time1[T3] > 1000)
				maxPower = 9;
			if(abs(pNow) < 50)
				maxPower = 5;

			lastPower = power;
			//Calculates the raw output
			power = (int)((kP*pNow + kI*iNow - kV*vNow)/1000);

			//Smooth change of motor power
			if(power - lastPower > slewRate)
				power = lastPower + slewRate;
			else if(lastPower - power > slewRate)
				power = lastPower - slewRate;

			//Limit to maximum power
			if(power > maxPower)
				power = maxPower;
			else if(power < -maxPower)
				power = -maxPower;

			//output to arm motor
			setArmMotorWithHighTech(power);
			delay(30);
		}
		delay(20);
	}
}

/************************************************************************************/
/******************************** Automous ******************************************/
/************************************************************************************/
#define MAX_CHOICE  3
#define MAX_CHOICE_LCD  2
static int autonomousMode = 0;
static int lcdTelemMode = 0;
bool mAutonBool = false;
int autonNumber = 0;

void pre_auton()
{
	bStopTasksBetweenModes = true;
}

#include "autons_raw.c"
task autonomous(){
	clearLCDLine(0);clearLCDLine(1);
	//clearTimer(T3);
	switch (autonomousMode){
		case 0:
			autoMode1();
			break;
		case 1:
			autoMode0();
			break;
		case 2:
			autoMode_prg();
			break;
		case 3:

			break;
		default:
			break;
	}
	//writeDebugStream("%d\n",time1[T3]);
}
/************************************************************************************/
/******************************* User control ***************************************/
/************************************************************************************/
void
LcdAutonomousSet( int value, bool select = false )
{
	if(select)
	    autonomousMode = value;

	if(autonomousMode == value)
	  	mAutonBool = true;
 	else mAutonBool = false;
}

task
LcdAutonomousSelection()
{
    TControllerButtons  button;
    autonNumber = 0;
    bLCDBacklight = true;
    mAutonBool = false;

    // diaplay default choice
    LcdAutonomousSet(0);

    while( true/*!mAutonBool*/ ){
        button = getLcdButtons();

        // Display and select the autonomous routine
        if( ( button == kButtonLeft ) || ( button == kButtonRight ) ) {
            // previous choice
            if( button == kButtonLeft )
                if( --autonNumber < 0 ) autonNumber = MAX_CHOICE;
            // next choice
            if( button == kButtonRight){
            		++lcdTelemMode;
                if( lcdTelemMode > MAX_CHOICE_LCD ) lcdTelemMode = 0;
                clearLCDLine(0);
              }

            LcdAutonomousSet(autonNumber);
			  }
        if( button == kButtonCenter)
            LcdAutonomousSet( autonNumber, true );

        delay(25);
   }
}

void
FwLcdControl_user()
{
	//currentL = getSensorPotLift();
	//motor_velocityL = (currentL - lastL) / 360 * 20 * 60;
	char str0[32]; char str1[32];
	switch(lcdTelemMode)
	{
		case 0:
			sprintf( str0, "D|L%d R%d", getEncLeft(), getEncRight() );
			break;
		case 1:
			sprintf( str0, "L|%d", getSensorPotLift() );
			break;
		case 2:
			sprintf( str0, "B|" );
			break;
		default:
			clearLCDLine(0); break;
	}
	sprintf( str1, "B(%d)%d %1.2f", mAutonBool, autonNumber, nImmediateBatteryLevel/1000.0 );
	displayLCDString(0, 0, str0);
	displayLCDString(1, 1, str1);
	delay(50);
}

task usercontrol()
{
	SensorValue[sENCL]=0;
	SensorValue[sENCR]=0;

	stopTask(armControl);
	stopTask(openClawOnTick);
	startTask(LcdAutonomousSelection);
	//startTask(MotorSlewRateTask);

	int threshold = 20;
	int mainX = 0,mainY = 0,secondaryX = 0,secondaryY = 0;
	int mPwrOff = true; //start with no static
	int mTogglePID = false;

	enum STATE{remainToBeDone, working, done, pause};
	enum STATE stata = done;
	int aim = LOWEST;
	long iNow;int pNow, vNow;
	int pLast;
	int kP, kI, kV, slewRate, maxPower;
	int power = 0, lastPower;

	while(true)
	{
		FwLcdControl_user();

		if(abs(vexRT[mainJoyY]) >= threshold)	mainY = vexRT[mainJoyY];
		else	mainY = 0;
		if(abs(vexRT[mainJoyX]) >= threshold)	mainX = vexRT[mainJoyX];
		else	mainX = 0;
		if(abs(vexRT[secondaryJoyY]) >= threshold)	secondaryY = vexRT[secondaryJoyY];
		else	secondaryY = 0;
		if(abs(vexRT[secondaryJoyX]) >= threshold)	secondaryX = vexRT[secondaryJoyX];
		else	secondaryX = 0;

		if(abs(mainY) < abs(secondaryY))
			mainY = secondaryY;
		if(abs(mainX) < 40)
			mainX /= 2;

		motor[mDRIVEL_1] = motor[mDRIVEL_2] = motor[mDRIVEL_3] = (-mainY + -mainX);
		motor[mDRIVER_1] = motor[mDRIVER_2] = motor[mDRIVER_3] = (-mainX - -mainY);

		//motor[mDRIVEL_1] = motor[mDRIVEL_2] = motor[mDRIVEL_3] = (-mainY + mainX);
		//motor[mDRIVER_1] = motor[mDRIVER_2] = motor[mDRIVER_3] = (mainX - -mainY);

		if( vexRT[Btn5U] )	pwrClaw(127);
		else if( vexRT[Btn5D] )	pwrClaw(-100);
		else if( vexRT[Btn8R] )	putOutClawMid();
		else if( !vexRT[Btn5U] && !vexRT[Btn5D] ) pwrClaw(0);


		if( vexRT[Btn6D] ){
			aim = LOWEST;
			stata = done;
			setArmMotor(-127);
			mPwrOff=false;
			mTogglePID=false;
		}
		else if( vexRT[Btn6U] && getSensorPotLift()<3250 ){
			aim = HIGHEST;
			stata = done;
			setArmMotor(127);
			mPwrOff=false;
			mTogglePID=true;
		}
		else if( vexRT[Btn8D] )	mPwrOff=true;
		else if( !vexRT[Btn6D] && !vexRT[Btn6U] && !vexRT[Btn8D] ){

			if( getSensorPotLift()<1150 && !mPwrOff )	setArmMotor(-7);
			else if( getSensorPotLift()>1150 && getSensorPotLift()<1850 && !mPwrOff && mTogglePID ) {
				//reset timer, double click preventer
				mTogglePID=false;
				aim = getSensorPotLift()+200;
				stata=remainToBeDone;
			}
			else setArmMotor(0);

		}

		if(aim != HIGHEST && aim != LOWEST && !mPwrOff)
		{
			if(stata == remainToBeDone)//The first cycle of PID, initialization
				{
					stata = working;
					pLast = pNow = aim - getSensorPotLift();
					iNow = 0;
					vNow = 0;
					clearTimer(T3);
				}
				else//Process sensor data
				{
					pLast = pNow;
					pNow = aim - getSensorPotLift();
					iNow += pNow;
					vNow = pLast - pNow;
				}

				//Dynamically set parameters
				kP = 60;
				kI = 10;
				if(abs(kI*iNow) > 40000)//When stuck, remove the exception
					iNow = 40000/kI*sgn(iNow);
				kV = 400;
				slewRate = 15;

				maxPower = 127;
				if(time1[T3] > 500)
					maxPower = 25;
				if(time1[T3] > 1000)
					maxPower = 9;
				if(abs(pNow) < 50)
					maxPower = 5;

				lastPower = power;
				//Calculates the raw output
				power = (int)((kP*pNow + kI*iNow - kV*vNow)/1000);

				//Smooth change of motor power
				if(power - lastPower > slewRate)
					power = lastPower + slewRate;
				else if(lastPower - power > slewRate)
					power = lastPower - slewRate;

				//Limit to maximum power
				if(power > maxPower)
					power = maxPower;
				else if(power < -maxPower)
					power = -maxPower;

				//output to arm motor
				setArmMotorWithHighTech(power);
		}
		delay(30);
	}
}
